//===----------------------------------------------------------------------===//
//
//                         Peloton
//
// gc_test.cpp
//
// Identification: test/gc/gc_test.cpp
//
// Copyright (c) 2015-16, Carnegie Mellon University Database Group
//
//===----------------------------------------------------------------------===//

#include "concurrency/testing_transaction_util.h"
#include "executor/testing_executor_util.h"
#include "common/harness.h"
#include "gc/gc_manager.h"
#include "gc/gc_manager_factory.h"
#include "concurrency/epoch_manager.h"


#include "catalog/catalog.h"
#include "storage/data_table.h"
#include "storage/tile_group.h"
#include "storage/database.h"


namespace peloton {
namespace test {

//===--------------------------------------------------------------------===//
// Transaction Tests
//===--------------------------------------------------------------------===//

class GarbageCollectionTests : public PelotonTest {};

int UpdateTuple(storage::DataTable *table, const int scale, const int num_key,
const int num_txn) {
  srand(15721);


  auto &txn_manager = concurrency::TransactionManagerFactory::GetInstance();

  TransactionScheduler scheduler(num_txn, table, &txn_manager);
  scheduler.SetConcurrent(true);
  for (int i = 0; i < num_txn; i++) {
    for (int j = 0; j < scale; j++) {
      // randomly select two uniq keys
      int key1 = rand() % num_key;
      int key2 = rand() % num_key;
      int delta = rand() % 1000;
      
      // Store substracted value
      scheduler.Txn(i).ReadStore(key1, -delta);
      scheduler.Txn(i).Update(key1, TXN_STORED_VALUE);
      // Store increased value
      scheduler.Txn(i).ReadStore(key2, delta);
      scheduler.Txn(i).Update(key2, TXN_STORED_VALUE);
    }
    scheduler.Txn(i).Commit();
  }
  scheduler.Run();

  // stats
  int nabort = 0;
  for (auto &schedule : scheduler.schedules) {
    if (schedule.txn_result == ResultType::ABORTED) nabort += 1;
  }
  LOG_INFO("Abort: %d out of %d", nabort, num_txn);
  return num_txn - nabort;
}


void SelectTuple(storage::DataTable *table, const int num_key) {
  auto &txn_manager = concurrency::TransactionManagerFactory::GetInstance();
  TransactionScheduler scheduler(1, table, &txn_manager);
  for (int i = 0; i < num_key; i++) {
    scheduler.Txn(0).Read(i);
  }
  scheduler.Txn(0).Commit();
  scheduler.Run();

  EXPECT_TRUE(scheduler.schedules[0].txn_result == ResultType::SUCCESS);
}

// count number of expired versions.
int GarbageNum(storage::DataTable *table) {
  auto table_tile_group_count_ = table->GetTileGroupCount();
  auto current_tile_group_offset_ = START_OID;

  int old_num = 0;

  while (current_tile_group_offset_ < table_tile_group_count_) {
    auto tile_group =
      table->GetTileGroup(current_tile_group_offset_++);
    auto tile_group_header = tile_group->GetHeader();
    oid_t active_tuple_count = tile_group->GetNextTupleSlot();

    for (oid_t tuple_id = 0; tuple_id < active_tuple_count; tuple_id++) {
      auto tuple_txn_id = tile_group_header->GetTransactionId(tuple_id);
      auto tuple_end_cid = tile_group_header->GetEndCommitId(tuple_id);
      if(tuple_txn_id == INITIAL_TXN_ID && tuple_end_cid != MAX_CID) {
        old_num++;
      }
    }
  }

  LOG_INFO("old version num %d", old_num);
  return old_num;
}

// get tuple recycled by GC
int RecycledNum(storage::DataTable *table) {
  int count = 0;
  auto table_id = table->GetOid();
  while(!gc::GCManagerFactory::GetInstance().ReturnFreeSlot(table_id).IsNull())
    count++;

  return count;
}


TEST_F(GarbageCollectionTests, SimpleTest) {

  std::vector<std::unique_ptr<std::thread>> gc_threads;

  gc::GCManagerFactory::Configure(1);
  auto &gc_manager = gc::GCManagerFactory::GetInstance();

  auto &epoch_manager = concurrency::EpochManagerFactory::GetInstance();
  epoch_manager.Reset(1);
  
  auto catalog = catalog::Catalog::GetInstance();
  // create database
  auto database = TestingExecutorUtil::InitializeDatabase(DEFAULT_DB_NAME);
  oid_t db_id = database->GetOid();
  EXPECT_TRUE(catalog->HasDatabase(db_id));

  // create a table with only one key
  const int num_key = 1;
  std::unique_ptr<storage::DataTable> table(
    TestingTransactionUtil::CreateTable(num_key, "TEST_TABLE", db_id, INVALID_OID, 1234, true));

  EXPECT_TRUE(gc_manager.GetTableCount() == 1);

  gc_manager.StartGC(gc_threads);

  // update this key 1 times, using only one thread
  const int scale = 1;
  const int thread_num = 1;
  auto succ_num = UpdateTuple(table.get(), scale, num_key, thread_num);

  // transaction must be committed
  EXPECT_EQ(succ_num, 1);

  // count garbage num
  auto old_num = GarbageNum(table.get());

  // there should be only one garbage
  // generated by the last update
  EXPECT_EQ(old_num, 1);
  
  for (size_t i = 2; i < 12; ++i) {
    epoch_manager.Reset(i);
    SelectTuple(table.get(), num_key);  
  }
  
  // sleep a while for gc to finish its job
  std::this_thread::sleep_for(std::chrono::seconds(1));

  for (size_t i = 12; i < 22; ++i) {
    epoch_manager.Reset(i);
    SelectTuple(table.get(), num_key);  
  }

  // sleep a while for gc to finish its job
  std::this_thread::sleep_for(std::chrono::seconds(1));

  // there should be no garbage
  old_num = GarbageNum(table.get());
  EXPECT_EQ(old_num, 0);

  // there should be 1 tuple recycled
  EXPECT_EQ(1, RecycledNum(table.get()));

  gc_manager.StopGC();

  table.release();
  
  // DROP!
  TestingExecutorUtil::DeleteDatabase(DEFAULT_DB_NAME);
  EXPECT_FALSE(catalog->HasDatabase(db_id));

  gc::GCManagerFactory::Configure(0);

  for (auto &gc_thread : gc_threads) {
    gc_thread->join();
  }
}


}  // End test namespace
}  // End peloton namespace
