//===----------------------------------------------------------------------===//
//
//                         Peloton
//
// tuple_samples_storage.cpp
//
// Identification: src/optimizer/stats/tuple_samples_storage.cpp
//
// Copyright (c) 2015-16, Carnegie Mellon University Database Group
//
//===----------------------------------------------------------------------===//

#include "optimizer/stats/tuple_samples_storage.h"
#include "catalog/catalog.h"
#include "storage/data_table.h"

namespace peloton {
namespace optimizer {

// Get instance of the global tuple samples storage
TupleSamplesStorage *TupleSamplesStorage::GetInstance(void) {
  static std::unique_ptr<TupleSamplesStorage> global_tuple_samples_storage(
      new TupleSamplesStorage());
  return global_tuple_samples_storage.get();
}

/**
 * TuplesSamplesStorage - Constructor of TuplesSamplesStorage.
 * In the construcotr, `stats` table and `samples_db` database are created.
 */
TupleSamplesStorage::TupleSamplesStorage() {
  pool_.reset(new type::EphemeralPool());
  CreateSamplesDatabase();
}

/**
 * CreateSamplesDatabase - Create a database for storing samples tables.
 */
void TupleSamplesStorage::CreateSamplesDatabase() {
  auto &txn_manager = concurrency::TransactionManagerFactory::GetInstance();
  auto txn = txn_manager.BeginTransaction();
  catalog::Catalog::GetInstance()->CreateDatabase(SAMPLES_DB_NAME, txn);
  txn_manager.CommitTransaction(txn);
}

/**
 * AddSamplesTable - Add a samples table into the 'samples_db'.
 * The table name is generated by concatenating db_id and table_id with '_'.
 */
void TupleSamplesStorage::AddSamplesTable(
    storage::DataTable *data_table,
    std::vector<std::unique_ptr<storage::Tuple>> &sampled_tuples) {
  auto schema = data_table->GetSchema();
  auto schema_copy = catalog::Schema::CopySchema(schema);
  std::unique_ptr<catalog::Schema> schema_ptr(schema_copy);
  auto catalog = catalog::Catalog::GetInstance();
  bool is_catalog = false;
  std::string samples_table_name = GenerateSamplesTableName(
      data_table->GetDatabaseOid(), data_table->GetOid());

  auto &txn_manager = concurrency::TransactionManagerFactory::GetInstance();
  auto txn = txn_manager.BeginTransaction();
  catalog->CreateTable(std::string(SAMPLES_DB_NAME), samples_table_name,
                       std::move(schema_ptr), txn, is_catalog);

  auto samples_table = catalog->GetTableWithName(std::string(SAMPLES_DB_NAME),
                                                 samples_table_name, txn);

  for (auto &tuple : sampled_tuples) {
    InsertSampleTuple(samples_table, std::move(tuple), txn);
  }
  txn_manager.CommitTransaction(txn);
}

bool TupleSamplesStorage::InsertSampleTuple(
    storage::DataTable *samples_table, std::unique_ptr<storage::Tuple> tuple,
    concurrency::Transaction *txn) {
  if (txn == nullptr) {
    return false;
  }

  std::unique_ptr<executor::ExecutorContext> context(
      new executor::ExecutorContext(txn));
  planner::InsertPlan node(samples_table, std::move(tuple));
  executor::InsertExecutor executor(&node, context.get());
  executor.Init();
  bool status = executor.Execute();

  return status;
}

/**
 * GetTupleSamples - Query tuple samples by db_id and table_id.
 * TODO: Implement this function.
 */
void TupleSamplesStorage::GetTupleSamples(
    UNUSED_ATTRIBUTE oid_t database_id, UNUSED_ATTRIBUTE oid_t table_id,
    UNUSED_ATTRIBUTE std::vector<storage::Tuple> &tuple_samples) {}

/**
 * GetColumnSamples - Query column samples by db_id, table_id and column_id.
 * TODO: Implement this function.
 */
void TupleSamplesStorage::GetColumnSamples(
    UNUSED_ATTRIBUTE oid_t database_id, UNUSED_ATTRIBUTE oid_t table_id,
    UNUSED_ATTRIBUTE oid_t column_id,
    UNUSED_ATTRIBUTE std::vector<type::Value> &column_samples) {}

} /* namespace optimizer */
} /* namespace peloton */
